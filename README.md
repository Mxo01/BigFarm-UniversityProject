 MARIO DI MODICA CORSO B 621595

Il progetto è suddiviso in 3 principali file:

1) farm.c che rappresenta il processo principale MasterWorker con un main thread (che svolge la funzione di unico produttore) e n thread ausiliari (che svolgono la funzione di consumatori). Come appena specificato, quindi, l'eseguibile farm è suddiviso in due parti:
- Main thread: come prima cosa inizializzo le modalità di gestione del segnale SIGINT creando una struct sigaction di nome "sa" che conterrà il modo in cui verrà gestito il segnale. Di seguito inizializzo sa al valore precedente (ovvero iniziale) e definisco il comportamente di sa passandogli l'indirizzo della funzione di gestione "handler". Dato che il programma deve finire le tasks correnti ed arrestarsi una volta ricevuto il segnale, ho gestito la seguente richiesta mediante l'utilizzo di una variabile globale di tipo volatile sig_atomic_t chiamata "continua" ed inizializzata a 1. Con l'istruzione sigaction(SIGINT, &sa, NULL) garantisco che il segnale SIGINT dovrà essere gestito come definito dalla struct sa quindi, una volta ricevuto il segnale verrà chiamata la funzione handler che "semplicemente" una volta ricevuto SIGINT setterà la variabile globale continua a 0 e comunicherà di aver ricevuto il segnale. All'interno del main() c'è un ciclo for che continua a leggere ciò che viene passato da linea di comando scrivendolo nel buffer produttore/consumatori e si fermerà una volta finito di leggere tutti i file passati da linea di comando (esclusi i parametri opzionali grazie a optind) o se la variabile continua è stata settata a 0. Il prossimo passo per il main thread è quello di prendere correttamente tutti i parametri opzionali (indicati da un trattino "-n", "-q", "-t"). Per fare ciò uso un while e la funzione di libreria getopt() che in caso di errore restituisce "-1" (condizione di uscita dal while) e mediante una switch separo i vari casi dei parametri opzionali assegnandoli alle giuste variabili dopo aver fatto la conversione di optarg (variabile globale "esterna" che contiene il valore resituito dalla funzione getopt()) mediante la funzione di libreria atoi().
La parte che segue contiene una serie di dichiarazioni e inizializzazioni delle componenti principali per la tecnica produttore/consumatori, come ad esempio il buffer di dimensione fissata, gli indici produttore/consumatori, i thread e ciò di cui ha bisogno ognuno di essi e i semafori senza nome per controllare quanti slot liberi ha il buffer o quanti sono occupati.
Successivamente faccio partire gli n thread mediante un ciclo for (grazie alla pthread_create()) ed inizializzo ogni componente della struct dei workers che deve contenere: il buffer, l'indice relativo al buffer, un mutex per garantire mutua esclusione in caso di accesso al buffer ed i due semafori senza nome.
Dopo la fase di lettura degli argomenti passati da linea di comando si passa ad un ciclo for che permette di inserire all'interno del buffer produttore/consumatori un carattere speciale che indica la terminazione. Tale carattere "end", una volta letto da un generico thread worker gli permette di capire che non c'è più nulla da leggere ed è il momento di terminare uscendo dal ciclo while e terminando definitivamente tramite la pthread_exit(NULL). 
Il processo main thread quindi attende che tutti i thread workers capiscano di dover terminare (all'interno di un ciclo for) mediante una pthread_join() ed alla fine si dealloca la memoria utilizzata distruggendo il mutex ed i semafori.
- Workers: come prima, ogni thread worker deve convertire il parametro che gli viene passato ottenendo così una struct di workers. Successivamente (dopo una serie di inizializzazione tra le quali la somma da dover calcolare) il generico thread worker ha il compito di provare ad aprire (come se fosse un file) ogni elemento contenuto nel buffer, per fare ciò bisogna utilizzare correttamente i semafori e il mutex in quanto dobbiamo prima leggere dal buffer quello che ha scritto il main thread. Per ogni elemento letto quindi si controllerà se si tratta di un file o del carattere di terminazione "end", se siamo nel primo caso possiamo procedere con la lettura di tale file attraverso un do{} while() ed una fread() calcolando la somma richiesta per ogni file e mandando tale somma ed il relativo nome del file attraverso una socket al server collector.py.
Se invece leggo il carattere di terminazione semplicemente il thred termina.
Come prima cosa ogni client, prima di mandare qualunque cosa, manda il tipo di richiesta che sta effettuando al server in quanto bisogna creare un tipo di protocollo per permettere al server di capire chi sta effettuando la richiesta e che tipo di richiesta è. Quindi ogni worker manda attraverso la socket, nel seguente ordine, il tipo di richiesta (0 nel caso di MasterWorker), la lunghezza del nome del file, il nome del file e la somma che essendo un long (quindi di dimensione 8 byte) va spezzata in due int da 4 byte in quanto in C non esiste alcuna funzione che garantisca il passaggio di 8 byte mediante socket. Ovviamente il formato degli elementi passati mediante socket è diverso da quello di uso quotidiano nei programmi, infatti ogni elemento da passare attraverso la socket va prima convertito in formato big-endian mediante funzioni di libreria.
Una volta finito questo procedimento chiudo la socket e ho finito il lavoro del MasterWorker.

2) client.c rappresenta il secondo client all'interno del progetto e ha il compito di interrogare il server collector.py. Questo processo può essere chiamato da linea di comando con o senza argomenti (che devono essere dei long che rappresentano delle somme), se siamo nel primo caso (quindi richiesta di tipo 1), per ogni elemento letto da linea di comando bisogna per prima cosa mandare il tipo di richiesta al server e successivamente convertire la somma letta in un long tramite la funzione di libreria strtol(), poi bisogna spezzare tale somma in due int da 4 byte e mandarli attraverso la socket. A questo punto il client deve chiedere al server di inviargli i file relativi alle somme che lui gli ha mandato quindi deve leggere dalla socket il numero di coppie (somma, nomefile) che dovrà leggere, la lunghezza del nome del file, il nome del file e la somma che dovrò unire in un unico long da 8 byte, shiftando a sinistra i primi 4 byte di 32 bit e "sommandoli" agli ultimi 4 byte estesi.
Se invece il client viene chiamato senza argomenti (quindi richiesta di tipo 2), allora per prima cosa mando il tipo di richiesta al server e poi deve leggere dalla socket il numero di coppie (somma, nomefile) che dovrà leggere, la lunghezza del nome del file, il nome del file e la somma che dovrò unire in un unico long da 8 byte. Per riassumere, se la richiesta è di tipo 1 allora aprirò una socket per ogni somma che mando, se invece la richiesta è di tipo 2 aprirò una sola socket restituendo tutte le coppie (somma, nomefile).

3) collector.py rappresenta l'unico server all'interno del progetto e ha il compito di aprire il servere e gestire 3 tipi di richieste, una dai thread workers e due dal secondo client. Per gestire queste richieste ho creato un protocollo che permette al server di riconoscere da chi proviene la richiesta e di conseguenza che tipo di richiesta è.
Per prima cosa dichiaro un dizionario vuoto come variabile globale che conterrà tutte le coppie chiave-valore (nomefile, somma) che riceverà dai workers. All'interno del main invece creo il socket server, lo connetto all'host e alla porta tramite la funzione bind() e lo metto in ascolto di richieste tramite la funzione listen(). All'interno di un while true mi metto in attesa di una connesione tramite la funzione accept() e una volta ricevuta una richiesta leggo i primi 4 byte dalla socket che contengono il tipo di richiesta ricevuta. Converto tale richiesta tramite "struct.unpack()" e controllo di che tipo di richiesta si tratta:
- Richiesta dal MasterWorker (0): inizializzo un thread che si dovrà occupare di gestire la connessione tramite la funziona ausiliaria "gestisci_worker()" ed una volta fatto partire tramite t.start() manderà in esecuzione la funzione ausiliaria. Tale funzione dovrà leggere dalla socket, nel seguente ordine, la lunghezza del nome del file (convertirla), il nome del file (convertirlo) e la somma (convertirla) inserendo la coppia (somma: [lista di nomi di file...]) all'interno del dizionario (senza duplicati).
- Richiesta dal Client (1): inizializzo un thread che si dovrà occupare di gestire la connessione tramite la funziona ausiliaria "gestisci_client1()" ed una volta fatto partire tramite t.start() manderà in esecuzione la funzione ausiliaria. Tale funzione dovrà leggere dalla socket la somma (convertirla) e se essa è presente nel dizionario manderà il numero di coppie con tale somma, e per ogni file all' interno della lista relativa a quella somma manderà la lunghezza del nome del file, il nome del file e la somma attraverso la socket. Se la somma non è presente nel dizionario, semplicemente viene mandata come lunghezza 0 che farà capire al client che non esiste alcun file con quella somma e quindi stamperà "Nessun file".
- Richiesta dal Client (2): inizializzo un thread che si dovrà occupare di gestire la connessione tramite la funziona ausiliaria "gestisci_client2()" ed una volta fatto partire tramite t.start() manderà in esecuzione la funzione ausiliaria. Tale funzione calcola la lunghezza del dizionario iniziale e la spedisce tramite socket. Successivamente spedisco tramite socket tutte le coppie somma-nomefile.
- Richiesta di chiusura del server: il server non deve terminare spontaneamente, quindi se ricevo una richiesta diversa da queste 3 il server termina.
